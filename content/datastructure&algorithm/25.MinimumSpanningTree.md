---
title: "ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(Minimum Spanning Tree)"
metaTitle: "ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(Minimum Spanning Tree)"
---

## ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ ì´í•´

### 1. ì‹ ì¥ íŠ¸ë¦¬ ë€?
- Spanning Tree, ë˜ëŠ” ì‹ ì¥ íŠ¸ë¦¬ ë¼ê³  ë¶ˆë¦¬ì›€ (Spanning Treeê°€ ë³´ë‹¤ ìì—°ìŠ¤ëŸ¬ì›Œ ë³´ì„)
- ì›ë˜ì˜ ê·¸ë˜í”„ì˜ ëª¨ë“  ë…¸ë“œê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ì„œ íŠ¸ë¦¬ì˜ ì†ì„±ì„ ë§Œì¡±í•˜ëŠ” ê·¸ë˜í”„
- ì‹ ì¥ íŠ¸ë¦¬ì˜ ì¡°ê±´
  - ë³¸ë˜ì˜ ê·¸ë˜í”„ì˜ ëª¨ë“  ë…¸ë“œë¥¼ í¬í•¨í•´ì•¼ í•¨
  - ëª¨ë“  ë…¸ë“œê°€ ì„œë¡œ ì—°ê²°
  - íŠ¸ë¦¬ì˜ ì†ì„±ì„ ë§Œì¡±ì‹œí‚´ (ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ)
  
  ![cds](https://www.fun-coding.org/00_Images/spanningtree.png)
  
### 2. ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ 
- Minimum Spanning Tree, MST ë¼ê³  ë¶ˆë¦¬ì›€
- ê°€ëŠ¥í•œ Spanning Tree ì¤‘ì—ì„œ, ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œì¸ Spanning Treeë¥¼ ì§€ì¹­í•¨

![ds](https://www.fun-coding.org/00_Images/mst.png)

### 3. ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜
- ê·¸ë˜í”„ì—ì„œ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜ì´ ì¡´ì¬í•¨
- ëŒ€í‘œì ì¸ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜
  - Kruskalâ€™s algorithm (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜), Prim's algorithm (í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜)

### 4. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (Kruskal's algorithm)
1. ëª¨ë“  ì •ì ì„ ë…ë¦½ì ì¸ ì§‘í•©ìœ¼ë¡œ ë§Œë“ ë‹¤.
2. ëª¨ë“  ê°„ì„ ì„ ë¹„ìš©ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ê³ , ë¹„ìš©ì´ ì‘ì€ ê°„ì„ ë¶€í„° ì–‘ ëì˜ ë‘ ì •ì ì„ ë¹„êµí•œë‹¤.
3. ë‘ ì •ì ì˜ ìµœìƒìœ„ ì •ì ì„ í™•ì¸í•˜ê³ , ì„œë¡œ ë‹¤ë¥¼ ê²½ìš° ë‘ ì •ì ì„ ì—°ê²°í•œë‹¤. (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ëŠ” ì‚¬ì´í´ì´ ì—†ìœ¼ë¯€ë¡œ, ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ í•˜ëŠ” ê²ƒì„)

> íƒìš• ì•Œê³ ë¦¬ì¦˜ì„ ê¸°ì´ˆë¡œ í•˜ê³  ìˆìŒ (ë‹¹ì¥ ëˆˆ ì•ì˜ ìµœì†Œ ë¹„ìš©ì„ ì„ íƒí•´ì„œ, ê²°ê³¼ì ìœ¼ë¡œ ìµœì ì˜ ì†”ë£¨ì…˜ì„ ì°¾ìŒ)

![cds](https://www.fun-coding.org/00_Images/kruscal_internal1.png)
![cds](https://www.fun-coding.org/00_Images/kruscal_internal2.png)

### 5. Union-Find ì•Œê³ ë¦¬ì¦˜
- Disjoint Setì„ í‘œí˜„í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ í™œìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
- ê°„ë‹¨í•˜ê²Œ, ë…¸ë“œë“¤ ì¤‘ì— ì—°ê²°ëœ ë…¸ë“œë¥¼ ì°¾ê±°ë‚˜, ë…¸ë“œë“¤ì„ ì„œë¡œ ì—°ê²°í•  ë•Œ (í•©ì¹  ë•Œ) ì‚¬ìš©
- Disjoint Setì´ë€
  - ì„œë¡œ ì¤‘ë³µë˜ì§€ ì•ŠëŠ” ë¶€ë¶„ ì§‘í•©ë“¤ë¡œ ë‚˜ëˆ ì§„ ì›ì†Œë“¤ì— ëŒ€í•œ ì •ë³´ë¥¼ ì €ì¥í•˜ê³  ì¡°ì‘í•˜ëŠ” ìë£Œêµ¬ì¡°
  - ê³µí†µ ì›ì†Œê°€ ì—†ëŠ” (ì„œë¡œì†Œ) ìƒí˜¸ ë°°íƒ€ì ì¸ ë¶€ë¶„ ì§‘í•©ë“¤ë¡œ ë‚˜ëˆ ì§„ ì›ì†Œë“¤ì— ëŒ€í•œ ìë£Œêµ¬ì¡°ë¥¼ ì˜ë¯¸í•¨
  - Disjoint Set = ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡°

1. ì´ˆê¸°í™”
   - n ê°œì˜ ì›ì†Œê°€ ê°œë³„ ì§‘í•©ìœ¼ë¡œ ì´ë¤„ì§€ë„ë¡ ì´ˆê¸°í™”
![csd](https://www.fun-coding.org/00_Images/initial_findunion.png)

2. Union
   - ë‘ ê°œë³„ ì§‘í•©ì„ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹¨, ë‘ íŠ¸ë¦¬ë¥¼ í•˜ë‚˜ì˜ íŠ¸ë¦¬ë¡œ ë§Œë“¬
![dc](https://www.fun-coding.org/00_Images/union_findunion.png)

3. Find
   - ì—¬ëŸ¬ ë…¸ë“œê°€ ì¡´ì¬í•  ë•Œ, ë‘ ê°œì˜ ë…¸ë“œë¥¼ ì„ íƒí•´ì„œ, í˜„ì¬ ë‘ ë…¸ë“œê°€ ì„œë¡œ ê°™ì€ ê·¸ë˜í”„ì— ì†í•˜ëŠ”ì§€ íŒë³„í•˜ê¸° ìœ„í•´, ê° ê·¸ë£¹ì˜ ìµœìƒë‹¨ ì›ì†Œ (ì¦‰, ë£¨íŠ¸ ë…¸ë“œ)ë¥¼ í™•ì¸
![csd](https://www.fun-coding.org/00_Images/find_findunion.png)

### Union-Find ì•Œê³ ë¦¬ì¦˜ì˜ ê³ ë ¤í•  ì 
- Union ìˆœì„œì— ë”°ë¼ì„œ, ìµœì•…ì˜ ê²½ìš° ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ì™€ ê°™ì€ í˜•íƒœê°€ ë  ìˆ˜ ìˆìŒ.
- ì´ ë•ŒëŠ” Find/Union ì‹œ ê³„ì‚°ëŸ‰ì´ O(N) ì´ ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, í•´ë‹¹ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´, union-by-rank, path compression ê¸°ë²•ì„ ì‚¬ìš©í•¨ 

![cds](https://www.fun-coding.org/00_Images/worst_findunion.png)

### union-by-rank ê¸°ë²•
- ê° íŠ¸ë¦¬ì— ëŒ€í•´ ë†’ì´(rank)ë¥¼ ê¸°ì–µí•´ ë‘ê³ ,
- Unionì‹œ ë‘ íŠ¸ë¦¬ì˜ ë†’ì´(rank)ê°€ ë‹¤ë¥´ë©´, ë†’ì´ê°€ ì‘ì€ íŠ¸ë¦¬ë¥¼ ë†’ì´ê°€ í° íŠ¸ë¦¬ì— ë¶™ì„ (ì¦‰, ë†’ì´ê°€ í° íŠ¸ë¦¬ì˜ ë£¨íŠ¸ ë…¸ë“œê°€ í•©ì¹œ ì§‘í•©ì˜ ë£¨íŠ¸ ë…¸ë“œê°€ ë˜ê²Œ í•¨)
![sdc](https://www.fun-coding.org/00_Images/unionbyrank_findunion.png)

- ë†’ì´ê°€ h - 1 ì¸ ë‘ ê°œì˜ íŠ¸ë¦¬ë¥¼ í•©ì¹  ë•ŒëŠ” í•œ ìª½ì˜ íŠ¸ë¦¬ ë†’ì´ë¥¼ 1 ì¦ê°€ì‹œì¼œì£¼ê³ , ë‹¤ë¥¸ ìª½ì˜ íŠ¸ë¦¬ë¥¼ í•´ë‹¹ íŠ¸ë¦¬ì— ë¶™ì—¬ì¤Œ
![ds](https://www.fun-coding.org/00_Images/unionbyranksame_findunion.png)

- ì´ˆê¸°í™”ì‹œ, ëª¨ë“  ì›ì†ŒëŠ” ë†’ì´(rank) ê°€ 0 ì¸ ê°œë³„ ì§‘í•©ì¸ ìƒíƒœì—ì„œ, í•˜ë‚˜ì”© ì›ì†Œë¥¼ í•©ì¹  ë•Œ, union-by-rank ê¸°ë²•ì„ ì‚¬ìš©í•œë‹¤ë©´,
  - ë†’ì´ê°€ h ì¸ íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ì§€ë ¤ë©´, ë†’ì´ê°€ h - 1 ì¸ ë‘ ê°œì˜ íŠ¸ë¦¬ê°€ í•©ì³ì ¸ì•¼ í•¨
  - ë†’ì´ê°€ h - 1 ì¸ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ìµœì†Œ nê°œì˜ ì›ì†Œê°€ í•„ìš”í•˜ë‹¤ë©´, ë†’ì´ê°€ h ì¸ íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ì§€ê¸° ìœ„í•´ì„œëŠ” ìµœì†Œ 2nê°œì˜ ì›ì†Œê°€ í•„ìš”í•¨
  - ë”°ë¼ì„œ union-by-rank ê¸°ë²•ì„ ì‚¬ìš©í•˜ë©´, union/find ì—°ì‚°ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(N) ì´ ì•„ë‹Œ, O($log{N}$) ë¡œ ë‚®ì¶œ ìˆ˜ ìˆìŒ

### path compression
- Findë¥¼ ì‹¤í–‰í•œ ë…¸ë“œì—ì„œ ê±°ì³ê°„ ë…¸ë“œë¥¼ ë£¨íŠ¸ì— ë‹¤ì´ë ‰íŠ¸ë¡œ ì—°ê²°í•˜ëŠ” ê¸°ë²•
- Findë¥¼ ì‹¤í–‰í•œ ë…¸ë“œëŠ” ì´í›„ë¶€í„°ëŠ” ë£¨íŠ¸ ë…¸ë“œë¥¼ í•œë²ˆì— ì•Œ ìˆ˜ ìˆìŒ

![dcs](https://www.fun-coding.org/00_Images/pathcompression_findunion.png)

- union-by-rank ì™€ path compression ê¸°ë²• ì‚¬ìš©ì‹œ ì‹œê°„ ë³µì¡ë„ëŠ” ë‹¤ìŒ ê³„ì‚°ì‹ì„ ë§Œì¡±í•¨ì´ ì¦ëª…ë˜ì—ˆìŒ
  - O($M log^*{N}$)
  - $ log^*{N} $ ì€ ë‹¤ìŒ ê°’ì„ ê°€ì§ì´ ì¦ëª…ë˜ì—ˆìŒ
    - Nì´ $2^{65536}$ ê°’ì„ ê°€ì§€ë”ë¼ë„, $log^*{N}$ ì˜ ê°’ì´ 5ì˜ ê°’ì„ ê°€ì§€ë¯€ë¡œ, ê±°ì˜ O(1), ì¦‰ ìƒìˆ˜ê°’ì— ê°€ê¹ë‹¤ê³  ë³¼ ìˆ˜ ìˆìŒ

|N	|ğ‘™ğ‘œğ‘”âˆ—ğ‘|
|---|---|
|1	|0|
|2	|1|
|4	|2|
|16	|3|
|65536	|4|
|2^65536	|5|


### 6. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (Kruskal's algorithm) ì½”ë“œ ì‘ì„±

```py
mygraph = {
    'vertices': ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
    'edges': [
        (7, 'A', 'B'),
        (5, 'A', 'D'),
        (7, 'B', 'A'),
        (8, 'B', 'C'),
        (9, 'B', 'D'),
        (7, 'B', 'E'),
        (8, 'C', 'B'),
        (5, 'C', 'E'),
        (5, 'D', 'A'),
        (9, 'D', 'B'),
        (7, 'D', 'E'),
        (6, 'D', 'F'),
        (7, 'E', 'B'),
        (5, 'E', 'C'),
        (7, 'E', 'D'),
        (8, 'E', 'F'),
        (9, 'E', 'G'),
        (6, 'F', 'D'),
        (8, 'F', 'E'),
        (11, 'F', 'G'),
        (9, 'G', 'E'),
        (11, 'G', 'F')
    ]
}
```
```py
parent = dict()
rank = dict()


def find(node):
    # path compression ê¸°ë²•
    if parent[node] != node:
        parent[node] = find(parent[node])
    return parent[node]


def union(node_v, node_u):
    root1 = find(node_v)
    root2 = find(node_u)
    
    # union-by-rank ê¸°ë²•
    if rank[root1] > rank[root2]:
        parent[root2] = root1
    else:
        parent[root1] = root2
        if rank[root1] == rank[root2]:
            rank[root2] += 1
    
    
def make_set(node):
    parent[node] = node
    rank[node] = 0

def kruskal(graph):
    mst = list()
    
    # 1. ì´ˆê¸°í™”
    for node in graph['vertices']:
        make_set(node)
    
    # 2. ê°„ì„  weight ê¸°ë°˜ sorting
    edges = graph['edges']
    edges.sort()
    
    # 3. ê°„ì„  ì—°ê²° (ì‚¬ì´í´ ì—†ëŠ”)
    for edge in edges:
        weight, node_v, node_u = edge
        if find(node_v) != find(node_u):
            union(node_v, node_u)
            mst.append(edge)
    
    return mst

kruskal(mygraph)

[(5, 'A', 'D'),
 (5, 'C', 'E'),
 (6, 'D', 'F'),
 (7, 'A', 'B'),
 (7, 'B', 'E'),
 (9, 'E', 'G')]
```

### 7. ì‹œê°„ ë³µì¡ë„
- í¬ë£¨ìŠ¤ì»¬ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” O(E log E)
  - ë‹¤ìŒ ë‹¨ê³„ì—ì„œ 2ë²ˆ, ê°„ì„ ì„ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ì‹œê°„ì— ì¢Œìš°ë¨ (ì¦‰ ê°„ì„ ì„ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ì‹œê°„ì´ ê°€ì¥ í¼)
  1. ëª¨ë“  ì •ì ì„ ë…ë¦½ì ì¸ ì§‘í•©ìœ¼ë¡œ ë§Œë“ ë‹¤.
  2. ëª¨ë“  ê°„ì„ ì„ ë¹„ìš©ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ê³ , ë¹„ìš©ì´ ì‘ì€ ê°„ì„ ë¶€í„° ì–‘ ëì˜ ë‘ ì •ì ì„ ë¹„êµí•œë‹¤.
     - í€µì†ŒíŠ¸ë¥¼ ì‚¬ìš©í•œë‹¤ë©´ ì‹œê°„ ë³µì¡ë„ëŠ” O(n log n) ì´ë©°, ê°„ì„ ì´ n ì´ë¯€ë¡œ O(E log E)
  3. ë‘ ì •ì ì˜ ìµœìƒìœ„ ì •ì ì„ í™•ì¸í•˜ê³ , ì„œë¡œ ë‹¤ë¥¼ ê²½ìš° ë‘ ì •ì ì„ ì—°ê²°í•œë‹¤. (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ëŠ” ì‚¬ì´í´ì´ ì—†ìœ¼ë¯€ë¡œ, ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ í•˜ëŠ” ê²ƒì„)
     - union-by-rank ì™€ path compression ê¸°ë²• ì‚¬ìš©ì‹œ ì‹œê°„ ë³µì¡ë„ê°€ ê²°êµ­ ìƒìˆ˜ê°’ì— ê°€ê¹Œì›€, O(1)

![cds](https://www.fun-coding.org/00_Images/kruscal_time.png)

## ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬2

### 1. í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ (Prim's algorithm)
- ëŒ€í‘œì ì¸ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜
  - Kruskalâ€™s algorithm (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜), Prim's algorithm (í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜)
- í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ 
  - ì‹œì‘ ì •ì ì„ ì„ íƒí•œ í›„, ì •ì ì— ì¸ì ‘í•œ ê°„ì„ ì¤‘ ìµœì†Œ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ì •ì ì„ ì„ íƒí•˜ê³ , í•´ë‹¹ ì •ì ì—ì„œ ë‹¤ì‹œ ìµœì†Œ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ì •ì ì„ ì„ íƒí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ í™•ì¥í•´ê°€ëŠ” ë°©ì‹
- Kruskal's algorithm ê³¼ Prim's algorithm ë¹„êµ
  - ë‘˜ë‹¤, íƒìš• ì•Œê³ ë¦¬ì¦˜ì„ ê¸°ì´ˆë¡œ í•˜ê³  ìˆìŒ (ë‹¹ì¥ ëˆˆ ì•ì˜ ìµœì†Œ ë¹„ìš©ì„ ì„ íƒí•´ì„œ, ê²°ê³¼ì ìœ¼ë¡œ ìµœì ì˜ ì†”ë£¨ì…˜ì„ ì°¾ìŒ)
  - Kruskal's algorithmì€ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë¶€í„° ì„ íƒí•˜ë©´ì„œ MSTë¥¼ êµ¬í•¨
  - Prim's algorithmì€ íŠ¹ì • ì •ì ì—ì„œ ì‹œì‘, í•´ë‹¹ ì •ì ì— ì—°ê²°ëœ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ì„ ì„ íƒ, ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ì •ì ë“¤ì— ì—°ê²°ëœ ê°„ì„  ì¤‘ì—ì„œ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ì„ íƒí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ MSTë¥¼ êµ¬í•¨

### 2. ê·¸ë¦¼ìœ¼ë¡œ ì´í•´í•˜ëŠ” í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜
1. ì„ì˜ì˜ ì •ì ì„ ì„ íƒ, 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ì‚½ì…
2. ì„ íƒëœ ì •ì ì— ì—°ê²°ëœ ê°„ì„ ë“¤ì„ ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ì‚½ì…
3. ê°„ì„  ë¦¬ìŠ¤íŠ¸ì—ì„œ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê°„ì„ ë¶€í„° ì¶”ì¶œí•´ì„œ,
   - í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì´ 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ì´ë¯¸ ë“¤ì–´ ìˆë‹¤ë©´, ìŠ¤í‚µí•¨(cycle ë°œìƒì„ ë§‰ê¸° ìœ„í•¨)
   - í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì´ 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ë“¤ì–´ ìˆì§€ ì•Šìœ¼ë©´, í•´ë‹¹ ê°„ì„ ì„ ì„ íƒí•˜ê³ , í•´ë‹¹ ê°„ì„  ì •ë³´ë¥¼ 'ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬'ì— ì‚½ì…
4. ì¶”ì¶œí•œ ê°„ì„ ì€ ê°„ì„  ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œê±°
5. ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ë” ì´ìƒì˜ ê°„ì„ ì´ ì—†ì„ ë•Œê¹Œì§€ 3-4ë²ˆì„ ë°˜ë³µ

![sdc](https://www.fun-coding.org/00_Images/prim1.png)
![sdc](https://www.fun-coding.org/00_Images/prim2.png)
![sdc](https://www.fun-coding.org/00_Images/prim3.png)

### 3. í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ (Prim's algorithm) ì½”ë“œ ì‘ì„±

### heapq ë¼ì´ë¸ŒëŸ¬ë¦¬ í™œìš©ì„ í†µí•´ ìš°ì„ ìˆœìœ„ í ì‚¬ìš©í•˜ê¸°
- heapq.heappushë¥¼ í†µí•´ ë°ì´í„°ë¥¼ heap í˜•íƒœë¡œ ë„£ì„ ìˆ˜ ìˆìŒ (0ë²ˆ ì¸ë±ìŠ¤ë¥¼ ìš°ì„ ìˆœìœ„ë¡œ ì¸ì§€í•¨)

```py
import heapq

queue = []
graph_data = [[2, 'A'], [5, 'B'], [3, 'C']]

for edge in graph_data:
    heapq.heappush(queue, edge)
    
for index in range(len(queue)):
    print (heapq.heappop(queue))

print (queue)

[2, 'A']
[3, 'C']
[5, 'B']
[]
```

- heapq.heapify() í•¨ìˆ˜ë¥¼ í†µí•´ ë¦¬ìŠ¤íŠ¸ ë°ì´í„°ë¥¼ heap í˜•íƒœë¡œ í•œ ë²ˆì— ë³€í™˜í•  ìˆ˜ ìˆìŒ (0ë²ˆ ì¸ë±ìŠ¤ë¥¼ ìš°ì„ ìˆœìœ„ë¡œ ì¸ì§€í•¨)

```py
import heapq

graph_data = [[2, 'A'], [5, 'B'], [3, 'C']]

heapq.heapify(graph_data)
    
for index in range(len(graph_data)):
    print (heapq.heappop(graph_data))

print (graph_data)

[2, 'A']
[3, 'C']
[5, 'B']
[]
```

### collections ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ defaultdict í•¨ìˆ˜ í™œìš©í•˜ê¸°
- defaultdict í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ, keyì— ëŒ€í•œ valueë¥¼ ì§€ì •í•˜ì§€ ì•Šì•˜ì„ ì‹œ, ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¡œ ì´ˆê¸°í™”í•˜ê¸°

```py
from collections import defaultdict

list_dict = defaultdict(list)
print (list_dict['key1'])

[ ]
```

### í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ íŒŒì´ì¬ ì½”ë“œ
0. ëª¨ë“  ê°„ì„  ì •ë³´ë¥¼ ì €ì¥ (**adjacent_edges**)
1. ì„ì˜ì˜ ì •ì ì„ ì„ íƒ, 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©(**connected_nodes**)'ì— ì‚½ì…
2. ì„ íƒëœ ì •ì ì— ì—°ê²°ëœ ê°„ì„ ë“¤ì„ ê°„ì„  ë¦¬ìŠ¤íŠ¸(**candidate_edge_list**)ì— ì‚½ì…
3. ê°„ì„  ë¦¬ìŠ¤íŠ¸(**candidate_edge_list**)ì—ì„œ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê°„ì„ ë¶€í„° ì¶”ì¶œí•´ì„œ,
   - í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì´ 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ì´ë¯¸ ë“¤ì–´ ìˆë‹¤ë©´, ìŠ¤í‚µí•¨(cycle ë°œìƒì„ ë§‰ê¸° ìœ„í•¨)
   - í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì´ 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ë“¤ì–´ ìˆì§€ ì•Šìœ¼ë©´, í•´ë‹¹ ê°„ì„ ì„ ì„ íƒí•˜ê³ , í•´ë‹¹ ê°„ì„  ì •ë³´ë¥¼ 'ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(**mst**)'ì— ì‚½ì…
     - í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì ì˜ ê°„ì„ ë“¤ ì¤‘, 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©(**connected_nodes**)' ì— ì—†ëŠ” ë…¸ë“œì™€ ì—°ê²°ëœ ê°„ì„ ë“¤ë§Œ ê°„ì„  ë¦¬ìŠ¤íŠ¸(**candidate_edge_list**) ì— ì‚½ì… 
       - 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©(**connected_nodes**)' ì— ìˆëŠ” ë…¸ë“œì™€ ì—°ê²°ëœ ê°„ì„ ë“¤ì„ ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ì‚½ì…í•´ë„, í•´ë‹¹ ê°„ì„ ì€ ìŠ¤í‚µë  ê²ƒì´ê¸° ë•Œë¬¸ì„
       - ì–´ì°¨í”¼ ìŠ¤í‚µë  ê°„ì„ ì„ ê°„ì„  ë¦¬ìŠ¤íŠ¸(**candidate_edge_list**)ì— ë„£ì§€ ì•Šìœ¼ë¯€ë¡œ í•´ì„œ, ê°„ì„  ë¦¬ìŠ¤íŠ¸(**candidate_edge_list**)ì—ì„œ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê°„ì„ ë¶€í„° ì¶”ì¶œí•˜ê¸° ìœ„í•œ ìë£Œêµ¬ì¡° ìœ ì§€ë¥¼ ìœ„í•œ effortë¥¼ ì¤„ì¼ ìˆ˜ ìˆìŒ (ì˜ˆ, ìµœì†Œí™ êµ¬ì¡° ì‚¬ìš©)
     
     
4. ì„ íƒëœ ê°„ì„ ì€ ê°„ì„  ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œê±°
5. ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ë” ì´ìƒì˜ ê°„ì„ ì´ ì—†ì„ ë•Œê¹Œì§€ 3-4ë²ˆì„ ë°˜ë³µ

```py
myedges = [
    (7, 'A', 'B'), (5, 'A', 'D'),
    (8, 'B', 'C'), (9, 'B', 'D'), (7, 'B', 'E'),
    (5, 'C', 'E'),
    (7, 'D', 'E'), (6, 'D', 'F'),
    (8, 'E', 'F'), (9, 'E', 'G'),
    (11, 'F', 'G')
]
```
```py
from collections import defaultdict
from heapq import *

def prim(start_node, edges):
    mst = list()
    adjacent_edges = defaultdict(list)
    for weight, n1, n2 in edges:
        adjacent_edges[n1].append((weight, n1, n2))
        adjacent_edges[n2].append((weight, n2, n1))

    connected_nodes = set(start_node)
    candidate_edge_list = adjacent_edges[start_node]
    heapify(candidate_edge_list)
    
    while candidate_edge_list:
        weight, n1, n2 = heappop(candidate_edge_list)
        if n2 not in connected_nodes:
            connected_nodes.add(n2)
            mst.append((weight, n1, n2))
            
            for edge in adjacent_edges[n2]:
                if edge[2] not in connected_nodes:
                    heappush(candidate_edge_list, edge)

    return mst

prim ('A', myedges)

[(5, 'A', 'D'),
 (6, 'D', 'F'),
 (7, 'A', 'B'),
 (7, 'B', 'E'),
 (5, 'E', 'C'),
 (9, 'E', 'G')]
```

### 4. ì‹œê°„ ë³µì¡ë„
  - ìµœì•…ì˜ ê²½ìš°, while êµ¬ë¬¸ì—ì„œ ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ ë°˜ë³µí•˜ê³ , ìµœì†Œ í™ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ O($ElogE$) ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§

### ê°œì„ ëœ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜
- ê°„ì„ ì´ ì•„ë‹Œ ë…¸ë“œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ íë¥¼ ì ìš©í•˜ëŠ” ë°©ì‹
  - ì´ˆê¸°í™” - ì •ì :key êµ¬ì¡°ë¥¼ ë§Œë“¤ì–´ë†“ê³ , íŠ¹ì • ì •ì ì˜ keyê°’ì€ 0, ì´ì™¸ì˜ ì •ì ë“¤ì˜ keyê°’ì€ ë¬´í•œëŒ€ë¡œ ë†“ìŒ.  ëª¨ë“  ì •ì :key ê°’ì€ ìš°ì„ ìˆœìœ„ íì— ë„£ìŒ
  - ê°€ì¥ keyê°’ì´ ì ì€ ì •ì :keyë¥¼ ì¶”ì¶œí•œ í›„(pop í•˜ë¯€ë¡œ í•´ë‹¹ ì •ì :key ì •ë³´ëŠ” ìš°ì„ ìˆœìœ„ íì—ì„œ ì‚­ì œë¨), (extract min ë¡œì§ì´ë¼ê³  ë¶€ë¦„)
  - í•´ë‹¹ ì •ì ì˜ ì¸ì ‘í•œ ì •ì ë“¤ì— ëŒ€í•´ key ê°’ê³¼ ì—°ê²°ëœ ê°€ì¤‘ì¹˜ ê°’ì„ ë¹„êµí•˜ì—¬ keyê°’ì´ ì‘ìœ¼ë©´ í•´ë‹¹ ì •ì :key ê°’ì„ ê°±ì‹ 
    - ì •ì :key ê°’ ê°±ì‹ ì‹œ, ìš°ì„ ìˆœìœ„ íëŠ” ìµœì†Œ keyê°’ì„ ê°€ì§€ëŠ” ì •ì :key ë¥¼ ë£¨íŠ¸ë…¸ë“œë¡œ ì˜¬ë ¤ë†“ë„ë¡ ì¬êµ¬ì„±í•¨ (decrease key ë¡œì§ì´ë¼ê³  ë¶€ë¦„)
- ê°œì„ ëœ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ì‹œ ê³ ë ¤ ì‚¬í•­
  - ìš°ì„ ìˆœìœ„ í(ìµœì†Œí™) êµ¬ì¡°ì—ì„œ, ì´ë¯¸ ë“¤ì–´ê°€ ìˆëŠ” ë°ì´í„°ì˜ ê°’ ë³€ê²½ì‹œ, ìµœì†Œê°’ì„ ê°€ì§€ëŠ” ë°ì´í„°ë¥¼ ë£¨íŠ¸ë…¸ë“œë¡œ ì˜¬ë ¤ë†“ë„ë¡ ì¬êµ¬ì„±í•˜ëŠ” ê¸°ëŠ¥ì´ í•„ìš”í•¨
  - êµ¬í˜„ ë³µì¡ë„ë¥¼ ì¤„ì´ê¸° ìœ„í•´, heapdict ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í†µí•´, í•´ë‹¹ ê¸°ëŠ¥ì„ ê°„ë‹¨íˆ êµ¬í˜„

```py
from heapdict import heapdict

def prim(graph, start):
    mst, keys, pi, total_weight = list(), heapdict(), dict(), 0
    for node in graph.keys():
        keys[node] = float('inf')
        pi[node] = None
    keys[start], pi[start] = 0, start

    while keys:
        current_node, current_key = keys.popitem()
        mst.append([pi[current_node], current_node, current_key])
        total_weight += current_key
        for adjacent, weight in mygraph[current_node].items():
            if adjacent in keys and weight < keys[adjacent]:
                keys[adjacent] = weight
                pi[adjacent] = current_node
    return mst, total_weight

mygraph = {
    'A': {'B': 7, 'D': 5},
    'B': {'A': 7, 'D': 9, 'C': 8, 'E': 7},
    'C': {'B': 8, 'E': 5},
    'D': {'A': 5, 'B': 9, 'E': 7, 'F': 6},
    'E': {'B': 7, 'C': 5, 'D': 7, 'F': 8, 'G': 9},
    'F': {'D': 6, 'E': 8, 'G': 11},
    'G': {'E': 9, 'F': 11}    
}
mst, total_weight = prim(mygraph, 'A')
print ('MST:', mst)
print ('Total Weight:', total_weight)

MST: [['A', 'A', 0], ['A', 'D', 5], ['D', 'F', 6], ['A', 'B', 7], ['D', 'E', 7], ['E', 'C', 5], ['E', 'G', 9]]
Total Weight: 39
```

### ê°œì„ ëœ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ ë³µì¡ë„:  O(ElogV) 
- ìµœì´ˆ key ìƒì„± ì‹œê°„ ë³µì¡ë„: O($V$) 
- while êµ¬ë¬¸ê³¼ keys.popitem() ì˜ ì‹œê°„ ë³µì¡ë„ëŠ”  O($VlogV$)
  - while êµ¬ë¬¸ì€ V(ë…¸ë“œ ê°¯ìˆ˜) ë²ˆ ì‹¤í–‰ë¨
  - heap ì—ì„œ ìµœì†Œ key ê°’ì„ ê°€ì§€ëŠ” ë…¸ë“œ ì •ë³´ ì¶”ì¶œ ì‹œ(pop)ì˜ ì‹œê°„ ë³µì¡ë„:  O($logV$) 
- for êµ¬ë¬¸ì˜ ì´ ì‹œê°„ ë³µì¡ë„ëŠ”  O($ElogV$) 
  - for êµ¬ë¬¸ì€ while êµ¬ë¬¸ ë°˜ë³µì‹œì— ê²°ê³¼ì ìœ¼ë¡œ ì´ ìµœëŒ€ ê°„ì„ ì˜ ìˆ˜ Eë§Œí¼ ì‹¤í–‰ ê°€ëŠ¥  O($E$) 
  - for êµ¬ë¬¸ ì•ˆì—ì„œ keyê°’ ë³€ê²½ì‹œë§ˆë‹¤ heap êµ¬ì¡°ë¥¼ ë³€ê²½í•´ì•¼ í•˜ë©°, heap ì—ëŠ” ìµœëŒ€ V ê°œì˜ ì •ë³´ê°€ ìˆìœ¼ë¯€ë¡œ  O($logV$) 
    > ì¼ë°˜ì ì¸ heap ìë£Œ êµ¬ì¡° ìì²´ì—ëŠ” ë³¸ë˜ heap ë‚´ë¶€ì˜ ë°ì´í„° ìš°ì„ ìˆœìœ„ ë³€ê²½ì‹œ, ìµœì†Œ ìš°ì„ ìˆœìœ„ ë°ì´í„°ë¥¼ ë£¨íŠ¸ë…¸ë“œë¡œ ë§Œë“¤ì–´ì£¼ëŠ” ë¡œì§ì€ ì—†ìŒ. ì´ë¥¼ decrease key ë¡œì§ì´ë¼ê³  ë¶€ë¦„, í•´ë‹¹ ë¡œì§ì€ heapdict ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•´ì„œ ê°„ë‹¨íˆ ì ìš©ê°€ëŠ¥
- ë”°ë¼ì„œ ì´ ì‹œê°„ ë³µì¡ë„ëŠ”  O($V + VlogV + ElogV$)  ì´ë©°,
  - O($V$)ëŠ” ì „ì²´ ì‹œê°„ ë³µì¡ë„ì— í° ì˜í–¥ì„ ë¯¸ì¹˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì‚­ì œ,
  - $E > V$ ì´ë¯€ë¡œ (ìµœëŒ€  $V^2 = E$  ê°€ ë  ìˆ˜ ìˆìŒ),  O($(V + E)logV$)  ëŠ” ê°„ë‹¨í•˜ê²Œ  O($ElogV$)  ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŒ